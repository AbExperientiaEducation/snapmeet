# Snapmeet Client
The snapmeet client is built using React for presentation and the Flux model for data flow.

## Record Storage and Retrieval
Resource records in Snapmeet are essentially POJOs. We instantiate them as Immutable Record objects, but they otherwise get no special methods.

Resources are created and changed through SMResource. However, we do not wait for a server response when creating or modifying records - it's fire and forget.

All server-changes come in as record pushes over a socket. We receive records through the SocketIOStore. There is no distinction between changes generated by the current user, and changes generated by other users.

Collections of SMResource records are stored in flux stores.

We also track associations as separate entities through the RelationStore. This is in keeping with our graph database approach; we have records for nodes (resources), and records for edges (relations)

### SMResource

Each record type has a singleton instance of SMResrouce that defines the record shape and provies the methods for API calls for that record type.  It might have been better to name SMResourceAPIFactory or something.

Note: There is a bit of code I"m not crazy about; when the client makes a new record, we feed it back in immediately as a server-created record (even though we don't have the official server copy yet). This is essentially just an optimistic update. We do this in a setTimeout because the action is initiated inside a dispatch on SMResourceStore. 

### SMResourceStore
This is the workhorse of the front-end. It's an EventEmitter that maintains our collections of resource records.  A point of terminology: 'subscribeToResource' means: if you don't have this record, put it in the store, and make sure we get any updates. 

As with SMResource, each record type has a singleton resource store that is constructed from SMResourceStore. 

SMResourceStore instances listen for updates for their record types, and adjust their store contents accordingly. 

The resourceStore also serves as the point of retrieval when we have a resourceId and want all the related records for that id. So if we want meeting tasks for a meeting, we ask the TaskStore for resourcesFromRelation(meetingId, 'MEETING_TASK'). It's a little weird that the TaskStore returns tasks for meeting Ids, and its possible we're missing an abstraction here.

### SocketIOStore
This stores the status of our socket.io connection, and also dispatches resource updates that have been pushed by the server.  These dispatches are picked up by the ResourceStores

### RelationStore
Unlike SMResource and SMResourceStore, there is only one RelationStore.

RelationStore maintains a list of node relationships keyed on node id. We treat our relationships as bi-directional, so whenever the store becomes aware of a new relation it adds it to the keys for both nodes.

### Future Work
We don't have any error handling for when server creation fails. The simplest mechanism would be for the server to send a socket event declaring the failure, and the client could purge the optimistically created resource from its store (and notify the user)

### Data flow
A React component (e.g. NewTaskButton) calls an action creator defined in TaskClientActions. This action calls the dispatcher with the type of action (create or patch), and the relevant record (or id of parent if creating new).

The dispatcher emits the event, which is picked up by the appropriate store. 

The store will call its patch or create methods, which in turn call methods on the corresponding SMResource. 

SMResource posts the data to the server, and forgets about it.

The server processes the data, and emits change events to any clients subscribed to that resource. This change event does not go through the flux dispatcher, it goes through Socket.io internals.

The change event is picked up by SocketIOStore, which calls ServerResourceActionCreators.receiveResources.  This dispatches a receive event with the received resources into the flux dispatcher.

SMResourceStores listen for these events, and add or update the returned resources in the store.

Components listening to the store have their change listener called, which causes them to update with the latest values.

## Components

### Visual style
We use MUI, a material UI library for React. At the time of implementation, it was the best choice for implement Material UI components in React, but many of its APIs are either overly restrictive, and the generated markup is a little clumsy.

### Separation of Business Logic and Display
Ideally we would have done more of this. While we did build many components using the PureRenderMixin, there are still many components that mix these concerns. I've been liking the container/component approach advocated by Abramov in Redux, and would probably refactor in that direction.

## Realtime inputs
Most text input and rendering happens outside of the flux flow. We let ShareJS directly manage meeting names and task titles, though we do react to changes by adjusting component dimensions to ensure text is visible.

The realtime editor is implemented by combining the Quill richtext editor with ShareJS. Quill is not built with React in mind, and the Quill box on the page is rendered once then not touched.

### SyncDoc Store
Components with realtime inputs subscribe to a ShareJS doc through the SyncDoc Store. We do route messages through Flux when new SyncDocs are created. This prompts the underlying components to attach to ShareJS, at which point their display is governed by ShareJS, not Flux.

## Videoconferencing

We use HTML5 webRTC APIs to do peer to peer videoconferencing in the browser. At the time of creating (and probably still), these APIs were "experimental" and in flux. We use the SimpleWebRTC library to wrap some of the lower level APIs and standardize across browsers.  While initially we had support for both Firefox and Chrome, the latest Firefox build no longer works correctly. 

Since the video is peer to peer and does not go through a central server, the bandwidth and processing requirements scale linearly with the number of users in the conference. We imposed an arbitrary limit of 5, after finding performance degradation on lower end machines beyond this point.

### SimpleWebRTC
The SimpleWebRTC library was constructed under a different set of assumptions than React. We had to fork the library to insert some callbacks we needed for playing nicely with the react component lifecycle.

### Video UI
Neither the browser APIs nor SimpleWebRTC provider any user interface components. We created a number of components for the purpose of rendering video calls.
- AudioIndicator
- MediaInputSelector
- PeerVideo
- SelfVideo
- VCBox

Of these, the Audio, and Peer/Self videos are display only components. Logic and lifting happens in VCBox, and MediaInputSelector